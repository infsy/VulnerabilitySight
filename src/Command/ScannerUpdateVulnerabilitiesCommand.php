<?php

namespace App\Command;

use App\Entity\Asset;
use App\Entity\Status;
use App\Entity\Vulnerability;
use App\Entity\VulnerabilityDetected;
use App\Entity\Detection;
use Symfony\Component\Console\Command\Command;
use Symfony\Bundle\FrameworkBundle\Command\ContainerAwareCommand;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Serializer\Serializer;
use Symfony\Component\Serializer\Encoder\CsvEncoder;
use Symfony\Component\Serializer\Normalizer\ObjectNormalizer;
use \Datetime;
use Unirest; 


class ScannerUpdateVulnerabilitiesCommand extends ContainerAwareCommand
{
    protected function configure()
    {
        $this
            ->setName('app:ScannerUpdateVulnerabilities')
            ->setDescription('This command synchronize vulnerabilities details from the scanner')
            ->setHelp('Get all vulnerabilities details from scanner and update those which are in the local database');
    }

    /**
     * @param InputInterface $input
     * @param OutputInterface $output
     * @return int|null|void
     */
    protected function execute(InputInterface $input, OutputInterface $output)
    {
        // initializing Container to work with Entities
        $em = $this->getContainer()->get('doctrine')->getManager();
        $em->getConnection()->getConfiguration()->setSQLLogger(null);

        // Connection to the API to retrieve session token
        $output->writeln('Connection to the API');
        $headers = array('Accept' => 'application/json');
        $data = array('username' => getenv('SCANNER_LOGIN'), 'password' => getenv('SCANNER_PASSWORD'));
        $body = Unirest\Request\Body::form($data);
        // We disable SSL verification
        Unirest\Request::verifyPeer(false);
        $response = Unirest\Request::post(getenv('SCANNER_SERVER') . '/session', $headers, $body);
        $token = $response->body->token;
        if (empty($token)) {
            $output->writeln('Session initialization failed');
        } else {
            $output->writeln('Session establishment succeed');
        }
        // The token is send in the defaultheader
        Unirest\Request::defaultHeader('X-Cookie', 'token=' . $token . '');

        // We parse the vulnerabilities stored in the database
        $vulnerabilities = $em->getRepository('App:Vulnerability')->findAll();

        foreach ($vulnerabilities as $vulnerability) {

            $output->writeln('Test de la vulnérabilité '.$vulnerability->getPluginId());

            // We retrieve the plugin details with the session token
        $response = Unirest\Request::get(getenv('SCANNER_SERVER') . '/plugins/plugin/'.$vulnerability->getPluginId(), $headers, '');

        foreach ($response->body->attributes as $attribut) {

        if ($attribut->attribute_name == 'cvss_base_score') {
            $vulnerability->setCvss($attribut->attribute_value);
        }
        elseif ($attribut->attribute_name == 'cve') {
            $vulnerability->setCve($attribut->attribute_value);
        }
        elseif ($attribut->attribute_name == 'exploit_available') {
                $vulnerability->setIsExploitable($attribut->attribute_value);
        }
        elseif ($attribut->attribute_name == 'see_also') {
                $vulnerability->setReferences($attribut->attribute_value);
        }
        elseif ($attribut->attribute_name == 'cvss_vector') {
                $vulnerability->setCvssVector($attribut->attribute_value);
        }
        elseif ($attribut->attribute_name == 'vuln_publication_date') {
            $dateElements = explode("/",$attribut->attribute_value);
            $publicationDate = new \DateTime($dateElements[0].'-'.$dateElements[1].'-'.$dateElements[2]);
            $vulnerability->setPublicationDate($publicationDate);
        }

        }
        $em->persist($vulnerability);

        }
        $em->flush();

        }

}
