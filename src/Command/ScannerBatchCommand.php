<?php

namespace App\Command;

use App\Entity\Asset;
use App\Entity\Status;
use App\Entity\Vulnerability;
use App\Entity\VulnerabilityDetected;
use App\Entity\Detection;
use App\Kernel;
use Symfony\Component\Console\Command\Command;
use Symfony\Bundle\FrameworkBundle\Command\ContainerAwareCommand;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Serializer\Serializer;
use Symfony\Component\Serializer\Encoder\CsvEncoder;
use Symfony\Component\Serializer\Normalizer\ObjectNormalizer;
use \Datetime;
use Unirest;
use Symfony\Component\Process\PhpExecutableFinder;
use Symfony\Component\HttpKernel\Kernel as BaseKernel;
use Symfony\Component\Process\Process;

class ScannerBatchCommand extends ContainerAwareCommand
{
    protected function configure()
    {
        $this
            ->setName('app:ScannerBatch')
            ->setDescription('This command synchronize scans from the scanner')
            ->addArgument('folderId', InputArgument::OPTIONAL, 'The folder to process')
            ->addArgument('scanId', InputArgument::OPTIONAL, 'The scan to process')
            ->setHelp('Get all scan details from scanner and store them in the local database');
    }

    /**
     * @param InputInterface $input
     * @param OutputInterface $output
     * @return int|null|void
     */
    protected function execute(InputInterface $input, OutputInterface $output)
    {
        // initializing Container to work with Entities
        $em = $this->getContainer()->get('doctrine')->getManager();
        $em->getConnection()->getConfiguration()->setSQLLogger(null);

        // Getting the path of PHP and of the project to fork multi threads
        $phpBinaryFinder = new PhpExecutableFinder();
        $phpBinaryPath = $phpBinaryFinder->find();
        $projectRoot = $this->getContainer()->get('kernel')->getProjectDir();

        // Connection to the API to retrieve session token
        $output->writeln('Connection to the API');
        $headers = array('Accept' => 'application/json');
        $data = array('username' => getenv('SCANNER_LOGIN'), 'password' => getenv('SCANNER_PASSWORD'));
        $body = Unirest\Request\Body::form($data);
        // We disable SSL verification
        Unirest\Request::verifyPeer(false);
        // We increase the Timeout
        Unirest\Request::timeout(3600);
        $response = Unirest\Request::post(getenv('SCANNER_SERVER') . '/session', $headers, $body);
        $token = $response->body->token;
        if (empty($token)) {
            $output->writeln('Session initialization failed');
        } else {
            $output->writeln('Session establishment succeed');
        }
        // The token is send in the defaultheader
        Unirest\Request::defaultHeader('X-Cookie', 'token=' . $token . '');

        // We retrieve the Folder list with the session token
        $response = Unirest\Request::get(getenv('SCANNER_SERVER') . '/folders', $headers, '');

        // We export data to csv file
        $serializer = new Serializer([new ObjectNormalizer()], [new CsvEncoder()]);
        $csvData = array(array('Folder', 'ScanName', 'Planification', 'LastExecution', 'Targets', 'NbreTargets'));

        // We go through each folder stored in the scanner
        foreach ($response->body->folders as $folder) {
            $output->writeln('Folder ' . $folder->name . ' is processed');
            if (!empty($input->getArgument('folderId'))) {
                // if user specified a folder id we continue the loop to the next each time it's not the good one
                if ($input->getArgument('folderId') != $folder->id) {
                    $output->writeln('Folder ' . $folder->name . ' unselected due to argument');
                    continue;
                }
            }

            $query = array('folder_id' => $folder->id);
            $responseScans = Unirest\Request::get(getenv('SCANNER_SERVER') . '/scans', $headers, $query);
            $output->writeln(count((array)$responseScans->body->scans) . ' scans in this Folder');

            // On n'exÃ©cute le traitement que si le Folder contient des scans
            if (!empty($responseScans->body->scans)) {
                $i = 1;
                // We ve got some scans in the folder processed
                foreach ($responseScans->body->scans as $scan) {
                    ${'process' . $i} = new Process(array($phpBinaryPath, $projectRoot . '/bin/console', 'app:ScannerGetScan', $scan->id, $scan->name));
                    ${'process' . $i}->setTimeout(9000);
                    ${'process' . $i}->start();
                    $output->writeln('Starting thread process' . $i);
                    ++$i;
                }

                // We wait for the termination of each of our process started
                for ($j = 1; $j < $i; $j++) {
                    ${'process' . $j}->wait();
                    $output->writeln('process' . $j . ' ended');
                }
            }
        }
    }
}
